{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary Blockchain Indexer and Web3 Tools Summary is a suite of tools that let Web3 developers: analyze blockchain data automate workflows with smart contract events create charts and dashboards store data for decentralized applications Summary Blockchain Indexer gathers blockchain data, decodes, persists and makes it available for analysis by GraphQL, SQL and API queries. We started with StarkNet L2 network and have its data indexed from both the main and test chains. The data is synced up to the latest block available from the network's API. You can query the data via GraphQL and SQL in our web console . Quick start Developer console is open to query blockchain data for events, transactions and their inputs, as well as to filter , aggregate and sum up values. Try this sample GraphQL in the middle pane editor. It queries for the latest block numbers and their hashes in both StarkNet chains mainnet and goerli . query latest_blocks { starknet_goerli_block(limit: 1, order_by: {block_number: desc}) {block_number block_hash} starknet_mainnet_block(limit: 1, order_by: {block_number: desc}) {block_number block_hash} } Now open the SQL console and try this select to query for the last 10 events emitted by StarkNet smart contracts in the test chain goerli. select * from starknet_goerli.event left join starknet_goerli.argument on starknet_goerli.argument.event_id = starknet_goerli.event.id order by starknet_goerli.event.id desc limit 10","title":"Home"},{"location":"#summary-blockchain-indexer-and-web3-tools","text":"Summary is a suite of tools that let Web3 developers: analyze blockchain data automate workflows with smart contract events create charts and dashboards store data for decentralized applications Summary Blockchain Indexer gathers blockchain data, decodes, persists and makes it available for analysis by GraphQL, SQL and API queries. We started with StarkNet L2 network and have its data indexed from both the main and test chains. The data is synced up to the latest block available from the network's API. You can query the data via GraphQL and SQL in our web console .","title":"Summary Blockchain Indexer and Web3 Tools"},{"location":"#quick-start","text":"Developer console is open to query blockchain data for events, transactions and their inputs, as well as to filter , aggregate and sum up values. Try this sample GraphQL in the middle pane editor. It queries for the latest block numbers and their hashes in both StarkNet chains mainnet and goerli . query latest_blocks { starknet_goerli_block(limit: 1, order_by: {block_number: desc}) {block_number block_hash} starknet_mainnet_block(limit: 1, order_by: {block_number: desc}) {block_number block_hash} } Now open the SQL console and try this select to query for the last 10 events emitted by StarkNet smart contracts in the test chain goerli. select * from starknet_goerli.event left join starknet_goerli.argument on starknet_goerli.argument.event_id = starknet_goerli.event.id order by starknet_goerli.event.id desc limit 10","title":"Quick start"},{"location":"api/","text":"API While the manual web console is useful to explore blockchain data with GraphQL queries, how do you build analytics tools and back end which would consume their results? You can automate with API calls with the same GraphQL queries as you tried in the console. The development process may start with you designing queries in the GraphQL console, combining and refining them. Once you figured out how to collect all the data you need, you can incorporate these query calls into your DApp frontend. Synchronous with http Try this http call with queries for both the decoded and the raw block 100000. We use curl for demo to send this http POST, but any other http client either in the browser or on the back can do the same. curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"{starknet_goerli_block(where: {block_number: {_eq: 100000}}) { transactions { function entry_point_selector inputs { name type value } events { name transmitter_contract arguments { name type value decimal } } } } starknet_goerli_raw_block_by_pk(block_number: 100000) { raw }}\"}' Asynchronous with WebSocket To get notified of changes to your query results use GraphQL subscriptions feature. It lets you connect via a WebSocket, pass your query as a subscription and your client will get called back once the results change. Use your favorite WebSocket or GraphQL client or our sample subscriber as a starting point to build web hooks that react to changes in blockchain data. This example invocation of our subscriber reacts to the latest three events emitted. npm start 'subscription {starknet_goerli_event(limit: 3, order_by: {id: desc}) {id, name}}' The subscription query can be of any complexity required to get the data you're interested in, and deliver changes in an arbitrary collection of entities.","title":"API"},{"location":"api/#api","text":"While the manual web console is useful to explore blockchain data with GraphQL queries, how do you build analytics tools and back end which would consume their results? You can automate with API calls with the same GraphQL queries as you tried in the console. The development process may start with you designing queries in the GraphQL console, combining and refining them. Once you figured out how to collect all the data you need, you can incorporate these query calls into your DApp frontend.","title":"API"},{"location":"api/#synchronous-with-http","text":"Try this http call with queries for both the decoded and the raw block 100000. We use curl for demo to send this http POST, but any other http client either in the browser or on the back can do the same. curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"{starknet_goerli_block(where: {block_number: {_eq: 100000}}) { transactions { function entry_point_selector inputs { name type value } events { name transmitter_contract arguments { name type value decimal } } } } starknet_goerli_raw_block_by_pk(block_number: 100000) { raw }}\"}'","title":"Synchronous with http"},{"location":"api/#asynchronous-with-websocket","text":"To get notified of changes to your query results use GraphQL subscriptions feature. It lets you connect via a WebSocket, pass your query as a subscription and your client will get called back once the results change. Use your favorite WebSocket or GraphQL client or our sample subscriber as a starting point to build web hooks that react to changes in blockchain data. This example invocation of our subscriber reacts to the latest three events emitted. npm start 'subscription {starknet_goerli_event(limit: 3, order_by: {id: desc}) {id, name}}' The subscription query can be of any complexity required to get the data you're interested in, and deliver changes in an arbitrary collection of entities.","title":"Asynchronous with WebSocket"},{"location":"howitworks/","text":"How it works Approach: write once We aim to solve the problem most DApp developers face: the data their smart contracts produce is buried in transaction inputs and events scattered in blocks. These data need to be gathered, parsed and interpreted for analysis (think an up-to-date TVL) and, finally, presented to the end users. This problem is often solved by an indexer , a service that listens to blockchain events, decodes and persists the emitted data. The code to interpret events is usually written by the DApp developers themselves and run by third parties, sometimes in a decentralized manner. While this multi-step approach gets the job done, it requires development effort better spent on the DApp itself, and creates friction between the many parts of the process. Our approach is a centralised service offering already decoded and normalized data ready for consumption and interpretation. We run one process to gather data from blockchains, decode it and persist in a relational database; there is no other secondary indexing or parsing. Once in the database, the data are already indexed and available for querying with SQL and GraphQL. Developers can use the up-to-date data right away without the need to write extra code, run multiple processes or involve third party indexers.","title":"How it works"},{"location":"howitworks/#how-it-works","text":"","title":"How it works"},{"location":"howitworks/#approach-write-once","text":"We aim to solve the problem most DApp developers face: the data their smart contracts produce is buried in transaction inputs and events scattered in blocks. These data need to be gathered, parsed and interpreted for analysis (think an up-to-date TVL) and, finally, presented to the end users. This problem is often solved by an indexer , a service that listens to blockchain events, decodes and persists the emitted data. The code to interpret events is usually written by the DApp developers themselves and run by third parties, sometimes in a decentralized manner. While this multi-step approach gets the job done, it requires development effort better spent on the DApp itself, and creates friction between the many parts of the process. Our approach is a centralised service offering already decoded and normalized data ready for consumption and interpretation. We run one process to gather data from blockchains, decode it and persist in a relational database; there is no other secondary indexing or parsing. Once in the database, the data are already indexed and available for querying with SQL and GraphQL. Developers can use the up-to-date data right away without the need to write extra code, run multiple processes or involve third party indexers.","title":"Approach: write once"},{"location":"queries/","text":"Query blockchain data with GraphQL We store blockchain data decoded and normalized in tables in a relational database. Then make this data available for querying by GraphQL and SQL. GraphQL lets you combine queries and retrieve records related and not, all by one query, saving you round trips getting them piece by piece like in REST APIs. It is also easier to construct than SQL and lends itself well to be used in API calls as it returns json. A developer can craft a GraphQL query in the web console and once it's perfected can send the same query to our http API endpoint. Queries with SQL can be more sophisticated and are used for grouping and joining records which would not be possible with GraphQL. These queries can then be wrapped into GraphQL by making them into persistent queries as views . Let's look at the basics of GraphQL queries for blockchain data. Explorer While you can write queries by hand you may find the GraphQL schema Explorer useful in the beginning. Open the pane on the left to put together a GraphQL query by selecting entities to return with their fields, and by adding filter, limit and sort parameters. Navigate to find entities you're interested in, like events in StarkNet test chain goerli . Open node starknet_goerli_event in the Explorer's tree and select the fields you want to retrieve like name . Smart contracts emit events with some payload that we parse into arguments , so select these in the tree together with their fields value and others. Filter There are millions of events in the database and you don't want to retrieve all of them, so let's narrow down the search by adding where clause filters and limit the number of records returned. Open the where node in the tree under starknet_goerli_event to add filter and limit conditions: event name field is equal _eq to Mint smart contract address that emitted the event _eq to 0x4b0... limit results to 3. One of the features of GraphQL is the ability to combine many entities in one query. To illustrate it here let's add a query for all DEPLOY transactions in block 100000, together with their inputs. Note here that you can filter entities at all levels: the block by its block_number and transactions within the block by their type . If you paste this query into the middle editor pane it will open the corresponding nodes in the Explorer: the panes work nicely together. { starknet_goerli_event(where: { name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 3) { name arguments { name type value decimal } transaction_hash } starknet_goerli_block(where: { block_number: {_eq: 100000}}) { transactions(where: {type: {_eq: \"DEPLOY\"}}) { function entry_point_selector inputs { name type value } } } } You can get query results directly from our http endpoint. Send the query you tried in the web console as an http POST parameter with curl : curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"{starknet_goerli_event(where: {name: {_eq: \\\"Mint\\\"}, transmitter_contract: {_eq: \\\"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\\\"}}, limit: 3) { name arguments { name type value decimal } transaction_hash} starknet_goerli_block(where: {block_number: {_eq: 100000}}) {transactions(where: {type: {_eq: \\\"DEPLOY\\\"}}) {function entry_point_selector inputs {name type value}}}}\"}' More on this in the section on our API . Input and event data decoded with ABI Blockchain APIs return transaction inputs and event payload in bulk arrays of binary data which are hard to interpret. We decode these for you with smart contract ABIs. For proxy contracts we attempt to find the implementation contract's ABI to parse the data correctly. Take a look at the transactions and events of block 100000 parsed and decoded. Try this query (which omits most fields for brevity). { starknet_goerli_block(where: {block_number: {_eq: 100000}}) { transactions { function entry_point_selector inputs { name type value } events { name transmitter_contract arguments { name type value decimal } } } } } Transaction function and its inputs are decoded using the contract's ABI. See smart contract function name decoded as execute together with its inputs: to as type felt , calldata as a three element felt array. { \"function\": \"execute\", \"entry_point_selector\": \"0x240060cdb34fcc260f41eac7474ee1d7c80b7e3607daff9ac67c7ea2ebb1c44\", \"inputs\": [ { \"name\": \"to\", \"type\": \"felt\", \"value\": \"0x4bc8ac16658025bff4a3bd0760e84fcf075417a4c55c6fae716efdd8f1ed26c\" }, { \"name\": \"selector\", \"type\": \"felt\", \"value\": \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\" }, { \"name\": \"calldata\", \"type\": \"felt[3]\", \"value\": [ \"0x263acca23357479031157e30053fe10598077f24f427ac1b1de85487f5cd124\", \"0x204fce5e3e25026110000000\", \"0x0\" ] }, { \"name\": \"nonce\", \"type\": \"felt\", \"value\": \"0x64\" } ] } Events are also decoded: see Transfer event and its argument tokenId as struct Uint256 with low and high hex, also converted into a decimal number. Converting from felt and Uint256 into decimal is useful for summing up and comparing values. { \"events\": [ { \"name\": \"Transfer\", \"transmitter_contract\": \"0x4e34321e0bce0e4ff8ff0bcb3a9a030d423bca29a9d99cbcdd60edb9a2bf03a\", \"arguments\": [ { \"name\": \"from_\", \"type\": \"felt\", \"value\": \"0x0\", \"decimal\": \"0\" }, { \"name\": \"to\", \"type\": \"felt\", \"value\": \"0x1778c6596d715a8613d0abcbe4fc08c052d208dce3b43eeb6b4dc24ddd62ed9\", \"decimal\": \"663536632620382607614490239145922341009321511960837718021901264100395462361\" }, { \"name\": \"tokenId\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x3d5b\", \"high\": \"0x0\" }, \"decimal\": \"15707\" } ] } ] } Let's get the raw block for comparison. Paste this into the GraphQL query window and you'll see raw block 100000 as we received it from the blockchain node API, with its transaction calldata and event payload data undecoded. { starknet_goerli_raw_block_by_pk(block_number: 100000) { raw } } The raw block has transaction inputs as calldata in a bulk array, like in this excerpt. { \"type\": \"INVOKE_FUNCTION\", \"max_fee\": \"0x0\", \"calldata\": [ \"0x4bc8ac16658025bff4a3bd0760e84fcf075417a4c55c6fae716efdd8f1ed26c\", \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\", \"0x3\", \"0x263acca23357479031157e30053fe10598077f24f427ac1b1de85487f5cd124\", \"0x204fce5e3e25026110000000\", \"0x0\", \"0x64\" ] } Event payload data is in bulk as well. { \"events\": [ { \"data\": [ \"0x0\", \"0x1778c6596d715a8613d0abcbe4fc08c052d208dce3b43eeb6b4dc24ddd62ed9\", \"0x3d5b\", \"0x0\" ], \"keys\": [ \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\" ], \"from_address\": \"0x4e34321e0bce0e4ff8ff0bcb3a9a030d423bca29a9d99cbcdd60edb9a2bf03a\" } ] } Query for your contract's events You are probably interested not in whole blocks but in events emitted by your own contract. Let's see how we can search with this query for Mint events of contract 0x4b0... , limited to one result for brevity. { starknet_goerli_event(where: { name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 1) { name arguments { name type value decimal } transaction_hash } } The query returns your event with its payload arguments decoded. { \"data\": { \"event\": [ { \"name\": \"Mint\", \"arguments\": [ { \"name\": \"sender\", \"type\": \"felt\", \"value\": \"0x1ea2f12a70ad6a052f99a49dace349996a8e968a0d6d4e9ec34e0991e6d5e5e\", \"decimal\": \"866079946690358847859985129991514658898248253189226492476287621475869744734\" }, { \"name\": \"amount0\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x52b7d2dcc80cd2e4000000\", \"high\": \"0x0\" }, \"decimal\": \"100000000000000000000000000\" }, { \"name\": \"amount1\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x2d79883d2000\", \"high\": \"0x0\" }, \"decimal\": \"50000000000000\" } ], \"transaction_hash\": \"0x521e56da1f33412f2f5e81dc585683c47b19783995aa3ebdcd84f5739cea489\" } ] } } You can send the same query to the http API endpoint; here we omitted the limit to get all Mint events. Such queries can be automated and feed your web and backend applications. curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"query { starknet_goerli_event(where: {name: {_eq: \\\"Mint\\\"}, transmitter_contract: {_eq: \\\"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\\\"}}) { name arguments { name type value decimal } transaction_hash }}\"}' Naturally, you can add as many conditions to where clause as needed to select the events you're interested in. This query returns 10 Mint events as starknet_goerli_event entities which have arguments with amount1 values less than 10. See the where clause selecting events with payload arguments with name _eq to amount1 and its value in decimal less than _lt 10. query event_mint_argument_amount1_lte_10 { starknet_goerli_event(where: { arguments: { name: {_eq: \"amount1\"}, decimal: {_lt: \"10\"} }, name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 10) { name arguments { name type value decimal } transaction_hash } } The following query accomplishes the same, but from the other end: it requests all arguments as starknet_goerli_argument entities, satisfying conditions amount1 and < 10 , and whose owning event is Mint of contract 0x4b0... . The query returns results as arguments together with their event, transaction and its block number. query argument_amount1_lte_10_event_mint { starknet_goerli_argument(where: { decimal: {_lt: \"10\"}, name: {_eq: \"amount1\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }, limit: 10) { decimal name type value event { transaction_hash transaction { block_number } } } } Another example query requests 10 Transfer events with a given destination address 0x455... specified by the to event argument. Note these events come from various contracts as seen in different transmitter_contract fields, and you can narrow down further if needed. query event_transfer_to { starknet_goerli_event(where: {name: {_eq: \"Transfer\"}, arguments: {name: {_eq: \"to\"}, value: {_eq: \"0x455eb02b7080a4ad5d2161cb94928acec81a4c9037b40bf106c4c797533c3e5\"}}} limit: 10) { name arguments { name type value decimal } transaction_hash transmitter_contract } } Query for values in JSON payloads Some event and transaction payload fields are atomic of type felt and are easily accessible by queries, but some are members of structs and are stored as json values. If the data you're interested in lies in a field inside json, you can get to it by specifying a path to this field in your query. This query searches for smart contract function input index_and_x of contract 0x579... which is defined as a struct. { starknet_goerli_input(where: {name: {_eq: \"index_and_x\"}, transaction: {contract_address: {_eq: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\"}}}, limit: 1) { value } } The result is the value of index_and_x as json with fields index and values . { \"data\": { \"input\": [ { \"value\": { \"index\": \"0x39103d23f38a0c91d4eebbc347a5170d00f4022cbb10bfa1def9ad49df782d6\", \"values\": [ \"0x586dbbbd0ba18ce0974f88a19489cca5fcd5ce29e723ad9b7d70e2ad9998a81\", \"0x6fefcb8a0e36b801fe98d66dc1513cce456970913b77b8058fea640a69daaa9\" ] } } ] } } The following query digs into json by specifying path values[1] to the second half of the tuple named values . Note the path is not part of the where clause but is applied to the returned field directly. { starknet_goerli_input(where: {name: {_eq: \"index_and_x\"}, transaction: {contract_address: {_eq: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\"}}}, limit: 1) { value(path: \"values[1]\") } } And returns bare y values of index_and_x : { \"data\": { \"input\": [ { \"value\": \"0x6fefcb8a0e36b801fe98d66dc1513cce456970913b77b8058fea640a69daaa9\" } ] } } Let's see what the ABI of our contract 0x579... looks like. { starknet_goerli_raw_abi_by_pk(contract_address: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\") { raw(path: \"[0]\") } } The type of index_and_x input is struct IndexAndValues . See its definition in the ABI that shows how to get the second half of the tuple values(x : felt, y : felt) by path: \"values[1]\" . { \"data\": { \"raw_abi_by_pk\": { \"raw\": { \"name\": \"IndexAndValues\", \"size\": 3, \"type\": \"struct\", \"members\": [ { \"name\": \"index\", \"type\": \"felt\", \"offset\": 0 }, { \"name\": \"values\", \"type\": \"(x : felt, y : felt)\", \"offset\": 1 } ] } } } } Proxy contracts Proxy contracts delegate transaction function calls to implementation contracts. Transaction input and event data are encoded per implementation contract's ABI. Implementation contracts change and with them changes the proxy contract's ABI. While interpreting proxy contract calls may be challenging, the data can still be decoded, by finding the implementation contract and its ABI. This is done by calling get_implementation or a similar method of the proxy contract, or by looking at the latest Upgraded or similarly named event indicating the implementation changed. This query requests three transactions sent to a proxy contract 0x474... . You see the first DEPLOY transaction setting the implementation contract address to 0x90a... . Let's add to the query a call to raw_abi to get ABIs for both proxy and implementation contracts, for demonstration. { starknet_goerli_transaction(limit: 3, where: {contract_address: {_eq: \"0x47495c732aa419dfecb43a2a78b4df926fddb251c7de0e88eab90d8a0399cd8\"}}) { inputs { type value name } function } starknet_goerli_raw_abi(where: {contract_address: {_in: [\"0x47495c732aa419dfecb43a2a78b4df926fddb251c7de0e88eab90d8a0399cd8\", \"0x90aa7a9203bff78bfb24f0753c180a33d4bad95b1f4f510b36b00993815704\"]}}) { contract_address raw } } See the contract function input call_array of type CallArray is defined in the implementation, not the proxy contract's ABI. { \"contract_address\": \"0x90aa7a9203bff78bfb24f0753c180a33d4bad95b1f4f510b36b00993815704\", \"raw\": [ { \"name\": \"CallArray\", \"size\": 4, \"type\": \"struct\", \"members\": [ { \"name\": \"to\", \"type\": \"felt\", \"offset\": 0 }, { \"name\": \"selector\", \"type\": \"felt\", \"offset\": 1 }, { \"name\": \"data_offset\", \"type\": \"felt\", \"offset\": 2 }, { \"name\": \"data_len\", \"type\": \"felt\", \"offset\": 3 } ] } ] } Yet call_array is still decoded properly as __execute__ function's input. See this excerpt from the query result: { \"inputs\": [ { \"type\": \"CallArray[1]\", \"value\": [ { \"to\": \"0x4c5327da1f289477951750208c9f97ca0f53afcd256d4363060268750b07f92\", \"data_len\": \"0x3\", \"selector\": \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\", \"data_offset\": \"0x0\" } ], \"name\": \"call_array\" }, { \"type\": \"felt[3]\", \"value\": [ \"0x30295374333e5b9fc34de3ef3822867eaa99af4c856ecf624d34574f8d7d8ea\", \"0xffffffffffffffffffffffffffffffff\", \"0xffffffffffffffffffffffffffffffff\" ], \"name\": \"calldata\" }, { \"type\": \"felt\", \"value\": \"0x0\", \"name\": \"nonce\" } ], \"function\": \"__execute__\" } Aggregation By now you know how to query for all your inputs and events, but how do you interpret them: sum them up, compare or calculate? Let's say you want to derive a number from some of your events, for example, to calculate Total Value Locked, which is a sum of arguments amount0 of all Mint events. One approach is to query for all of the values of amount0 ; here we limit results to 10 for brevity. { starknet_goerli_argument(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }, limit: 10) { type value name decimal } } See the values as Uint256 struct and also conveniently converted into decimals so you can sum them up. { \"type\": \"Uint256\", \"value\": { \"low\": \"0x52b7d2dcc80cd2e4000000\", \"high\": \"0x0\" }, \"name\": \"amount0\", \"decimal\": \"100000000000000000000000000\" } You can consume this query's results by your own software and sum up the values of amount0 . This is the approach of some other indexers. But since your data is already in a relational database's table, you can run an aggregation query over the values, which sums them up and returns the final result in the same query, all with no extra coding effort. That's why the values were converted into decimals when they were persisted: GraphQL query argument_aggregate calls a SQL query with an aggregation function sum over a numeric column. Database type numeric 78 used for the decimal column is large enough to support Uint256 and felt and arithmetic operations over them. This query aggregates decimal values of amount0 arguments of all Mint events. { starknet_goerli_argument_aggregate(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }) { aggregate { sum { decimal } avg { decimal } min { decimal } max { decimal } } } } Returns the total sum (TVL) as well as results of other aggregation functions: min, max, avg. { \"data\": { \"argument_aggregate\": { \"aggregate\": { \"sum\": { \"decimal\": \"7312519852578770281612328156\" }, \"avg\": { \"decimal\": \"148767543894266393001838\" }, \"min\": { \"decimal\": \"25047631971864\" }, \"max\": { \"decimal\": \"5000000000000000000000000000\" } } } } }","title":"Queries"},{"location":"queries/#query-blockchain-data-with-graphql","text":"We store blockchain data decoded and normalized in tables in a relational database. Then make this data available for querying by GraphQL and SQL. GraphQL lets you combine queries and retrieve records related and not, all by one query, saving you round trips getting them piece by piece like in REST APIs. It is also easier to construct than SQL and lends itself well to be used in API calls as it returns json. A developer can craft a GraphQL query in the web console and once it's perfected can send the same query to our http API endpoint. Queries with SQL can be more sophisticated and are used for grouping and joining records which would not be possible with GraphQL. These queries can then be wrapped into GraphQL by making them into persistent queries as views . Let's look at the basics of GraphQL queries for blockchain data.","title":"Query blockchain data with GraphQL"},{"location":"queries/#explorer","text":"While you can write queries by hand you may find the GraphQL schema Explorer useful in the beginning. Open the pane on the left to put together a GraphQL query by selecting entities to return with their fields, and by adding filter, limit and sort parameters. Navigate to find entities you're interested in, like events in StarkNet test chain goerli . Open node starknet_goerli_event in the Explorer's tree and select the fields you want to retrieve like name . Smart contracts emit events with some payload that we parse into arguments , so select these in the tree together with their fields value and others.","title":"Explorer"},{"location":"queries/#filter","text":"There are millions of events in the database and you don't want to retrieve all of them, so let's narrow down the search by adding where clause filters and limit the number of records returned. Open the where node in the tree under starknet_goerli_event to add filter and limit conditions: event name field is equal _eq to Mint smart contract address that emitted the event _eq to 0x4b0... limit results to 3. One of the features of GraphQL is the ability to combine many entities in one query. To illustrate it here let's add a query for all DEPLOY transactions in block 100000, together with their inputs. Note here that you can filter entities at all levels: the block by its block_number and transactions within the block by their type . If you paste this query into the middle editor pane it will open the corresponding nodes in the Explorer: the panes work nicely together. { starknet_goerli_event(where: { name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 3) { name arguments { name type value decimal } transaction_hash } starknet_goerli_block(where: { block_number: {_eq: 100000}}) { transactions(where: {type: {_eq: \"DEPLOY\"}}) { function entry_point_selector inputs { name type value } } } } You can get query results directly from our http endpoint. Send the query you tried in the web console as an http POST parameter with curl : curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"{starknet_goerli_event(where: {name: {_eq: \\\"Mint\\\"}, transmitter_contract: {_eq: \\\"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\\\"}}, limit: 3) { name arguments { name type value decimal } transaction_hash} starknet_goerli_block(where: {block_number: {_eq: 100000}}) {transactions(where: {type: {_eq: \\\"DEPLOY\\\"}}) {function entry_point_selector inputs {name type value}}}}\"}' More on this in the section on our API .","title":"Filter"},{"location":"queries/#input-and-event-data-decoded-with-abi","text":"Blockchain APIs return transaction inputs and event payload in bulk arrays of binary data which are hard to interpret. We decode these for you with smart contract ABIs. For proxy contracts we attempt to find the implementation contract's ABI to parse the data correctly. Take a look at the transactions and events of block 100000 parsed and decoded. Try this query (which omits most fields for brevity). { starknet_goerli_block(where: {block_number: {_eq: 100000}}) { transactions { function entry_point_selector inputs { name type value } events { name transmitter_contract arguments { name type value decimal } } } } } Transaction function and its inputs are decoded using the contract's ABI. See smart contract function name decoded as execute together with its inputs: to as type felt , calldata as a three element felt array. { \"function\": \"execute\", \"entry_point_selector\": \"0x240060cdb34fcc260f41eac7474ee1d7c80b7e3607daff9ac67c7ea2ebb1c44\", \"inputs\": [ { \"name\": \"to\", \"type\": \"felt\", \"value\": \"0x4bc8ac16658025bff4a3bd0760e84fcf075417a4c55c6fae716efdd8f1ed26c\" }, { \"name\": \"selector\", \"type\": \"felt\", \"value\": \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\" }, { \"name\": \"calldata\", \"type\": \"felt[3]\", \"value\": [ \"0x263acca23357479031157e30053fe10598077f24f427ac1b1de85487f5cd124\", \"0x204fce5e3e25026110000000\", \"0x0\" ] }, { \"name\": \"nonce\", \"type\": \"felt\", \"value\": \"0x64\" } ] } Events are also decoded: see Transfer event and its argument tokenId as struct Uint256 with low and high hex, also converted into a decimal number. Converting from felt and Uint256 into decimal is useful for summing up and comparing values. { \"events\": [ { \"name\": \"Transfer\", \"transmitter_contract\": \"0x4e34321e0bce0e4ff8ff0bcb3a9a030d423bca29a9d99cbcdd60edb9a2bf03a\", \"arguments\": [ { \"name\": \"from_\", \"type\": \"felt\", \"value\": \"0x0\", \"decimal\": \"0\" }, { \"name\": \"to\", \"type\": \"felt\", \"value\": \"0x1778c6596d715a8613d0abcbe4fc08c052d208dce3b43eeb6b4dc24ddd62ed9\", \"decimal\": \"663536632620382607614490239145922341009321511960837718021901264100395462361\" }, { \"name\": \"tokenId\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x3d5b\", \"high\": \"0x0\" }, \"decimal\": \"15707\" } ] } ] } Let's get the raw block for comparison. Paste this into the GraphQL query window and you'll see raw block 100000 as we received it from the blockchain node API, with its transaction calldata and event payload data undecoded. { starknet_goerli_raw_block_by_pk(block_number: 100000) { raw } } The raw block has transaction inputs as calldata in a bulk array, like in this excerpt. { \"type\": \"INVOKE_FUNCTION\", \"max_fee\": \"0x0\", \"calldata\": [ \"0x4bc8ac16658025bff4a3bd0760e84fcf075417a4c55c6fae716efdd8f1ed26c\", \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\", \"0x3\", \"0x263acca23357479031157e30053fe10598077f24f427ac1b1de85487f5cd124\", \"0x204fce5e3e25026110000000\", \"0x0\", \"0x64\" ] } Event payload data is in bulk as well. { \"events\": [ { \"data\": [ \"0x0\", \"0x1778c6596d715a8613d0abcbe4fc08c052d208dce3b43eeb6b4dc24ddd62ed9\", \"0x3d5b\", \"0x0\" ], \"keys\": [ \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\" ], \"from_address\": \"0x4e34321e0bce0e4ff8ff0bcb3a9a030d423bca29a9d99cbcdd60edb9a2bf03a\" } ] }","title":"Input and event data decoded with ABI"},{"location":"queries/#query-for-your-contracts-events","text":"You are probably interested not in whole blocks but in events emitted by your own contract. Let's see how we can search with this query for Mint events of contract 0x4b0... , limited to one result for brevity. { starknet_goerli_event(where: { name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 1) { name arguments { name type value decimal } transaction_hash } } The query returns your event with its payload arguments decoded. { \"data\": { \"event\": [ { \"name\": \"Mint\", \"arguments\": [ { \"name\": \"sender\", \"type\": \"felt\", \"value\": \"0x1ea2f12a70ad6a052f99a49dace349996a8e968a0d6d4e9ec34e0991e6d5e5e\", \"decimal\": \"866079946690358847859985129991514658898248253189226492476287621475869744734\" }, { \"name\": \"amount0\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x52b7d2dcc80cd2e4000000\", \"high\": \"0x0\" }, \"decimal\": \"100000000000000000000000000\" }, { \"name\": \"amount1\", \"type\": \"Uint256\", \"value\": { \"low\": \"0x2d79883d2000\", \"high\": \"0x0\" }, \"decimal\": \"50000000000000\" } ], \"transaction_hash\": \"0x521e56da1f33412f2f5e81dc585683c47b19783995aa3ebdcd84f5739cea489\" } ] } } You can send the same query to the http API endpoint; here we omitted the limit to get all Mint events. Such queries can be automated and feed your web and backend applications. curl https://hasura.prod.summary.dev/v1/graphql --data-raw '{\"query\":\"query { starknet_goerli_event(where: {name: {_eq: \\\"Mint\\\"}, transmitter_contract: {_eq: \\\"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\\\"}}) { name arguments { name type value decimal } transaction_hash }}\"}' Naturally, you can add as many conditions to where clause as needed to select the events you're interested in. This query returns 10 Mint events as starknet_goerli_event entities which have arguments with amount1 values less than 10. See the where clause selecting events with payload arguments with name _eq to amount1 and its value in decimal less than _lt 10. query event_mint_argument_amount1_lte_10 { starknet_goerli_event(where: { arguments: { name: {_eq: \"amount1\"}, decimal: {_lt: \"10\"} }, name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"} }, limit: 10) { name arguments { name type value decimal } transaction_hash } } The following query accomplishes the same, but from the other end: it requests all arguments as starknet_goerli_argument entities, satisfying conditions amount1 and < 10 , and whose owning event is Mint of contract 0x4b0... . The query returns results as arguments together with their event, transaction and its block number. query argument_amount1_lte_10_event_mint { starknet_goerli_argument(where: { decimal: {_lt: \"10\"}, name: {_eq: \"amount1\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }, limit: 10) { decimal name type value event { transaction_hash transaction { block_number } } } } Another example query requests 10 Transfer events with a given destination address 0x455... specified by the to event argument. Note these events come from various contracts as seen in different transmitter_contract fields, and you can narrow down further if needed. query event_transfer_to { starknet_goerli_event(where: {name: {_eq: \"Transfer\"}, arguments: {name: {_eq: \"to\"}, value: {_eq: \"0x455eb02b7080a4ad5d2161cb94928acec81a4c9037b40bf106c4c797533c3e5\"}}} limit: 10) { name arguments { name type value decimal } transaction_hash transmitter_contract } }","title":"Query for your contract's events"},{"location":"queries/#query-for-values-in-json-payloads","text":"Some event and transaction payload fields are atomic of type felt and are easily accessible by queries, but some are members of structs and are stored as json values. If the data you're interested in lies in a field inside json, you can get to it by specifying a path to this field in your query. This query searches for smart contract function input index_and_x of contract 0x579... which is defined as a struct. { starknet_goerli_input(where: {name: {_eq: \"index_and_x\"}, transaction: {contract_address: {_eq: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\"}}}, limit: 1) { value } } The result is the value of index_and_x as json with fields index and values . { \"data\": { \"input\": [ { \"value\": { \"index\": \"0x39103d23f38a0c91d4eebbc347a5170d00f4022cbb10bfa1def9ad49df782d6\", \"values\": [ \"0x586dbbbd0ba18ce0974f88a19489cca5fcd5ce29e723ad9b7d70e2ad9998a81\", \"0x6fefcb8a0e36b801fe98d66dc1513cce456970913b77b8058fea640a69daaa9\" ] } } ] } } The following query digs into json by specifying path values[1] to the second half of the tuple named values . Note the path is not part of the where clause but is applied to the returned field directly. { starknet_goerli_input(where: {name: {_eq: \"index_and_x\"}, transaction: {contract_address: {_eq: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\"}}}, limit: 1) { value(path: \"values[1]\") } } And returns bare y values of index_and_x : { \"data\": { \"input\": [ { \"value\": \"0x6fefcb8a0e36b801fe98d66dc1513cce456970913b77b8058fea640a69daaa9\" } ] } } Let's see what the ABI of our contract 0x579... looks like. { starknet_goerli_raw_abi_by_pk(contract_address: \"0x579f32b8090d8d789d4b907a8935a75f6de583c9d60893586e24a83d173b6d5\") { raw(path: \"[0]\") } } The type of index_and_x input is struct IndexAndValues . See its definition in the ABI that shows how to get the second half of the tuple values(x : felt, y : felt) by path: \"values[1]\" . { \"data\": { \"raw_abi_by_pk\": { \"raw\": { \"name\": \"IndexAndValues\", \"size\": 3, \"type\": \"struct\", \"members\": [ { \"name\": \"index\", \"type\": \"felt\", \"offset\": 0 }, { \"name\": \"values\", \"type\": \"(x : felt, y : felt)\", \"offset\": 1 } ] } } } }","title":"Query for values in JSON payloads"},{"location":"queries/#proxy-contracts","text":"Proxy contracts delegate transaction function calls to implementation contracts. Transaction input and event data are encoded per implementation contract's ABI. Implementation contracts change and with them changes the proxy contract's ABI. While interpreting proxy contract calls may be challenging, the data can still be decoded, by finding the implementation contract and its ABI. This is done by calling get_implementation or a similar method of the proxy contract, or by looking at the latest Upgraded or similarly named event indicating the implementation changed. This query requests three transactions sent to a proxy contract 0x474... . You see the first DEPLOY transaction setting the implementation contract address to 0x90a... . Let's add to the query a call to raw_abi to get ABIs for both proxy and implementation contracts, for demonstration. { starknet_goerli_transaction(limit: 3, where: {contract_address: {_eq: \"0x47495c732aa419dfecb43a2a78b4df926fddb251c7de0e88eab90d8a0399cd8\"}}) { inputs { type value name } function } starknet_goerli_raw_abi(where: {contract_address: {_in: [\"0x47495c732aa419dfecb43a2a78b4df926fddb251c7de0e88eab90d8a0399cd8\", \"0x90aa7a9203bff78bfb24f0753c180a33d4bad95b1f4f510b36b00993815704\"]}}) { contract_address raw } } See the contract function input call_array of type CallArray is defined in the implementation, not the proxy contract's ABI. { \"contract_address\": \"0x90aa7a9203bff78bfb24f0753c180a33d4bad95b1f4f510b36b00993815704\", \"raw\": [ { \"name\": \"CallArray\", \"size\": 4, \"type\": \"struct\", \"members\": [ { \"name\": \"to\", \"type\": \"felt\", \"offset\": 0 }, { \"name\": \"selector\", \"type\": \"felt\", \"offset\": 1 }, { \"name\": \"data_offset\", \"type\": \"felt\", \"offset\": 2 }, { \"name\": \"data_len\", \"type\": \"felt\", \"offset\": 3 } ] } ] } Yet call_array is still decoded properly as __execute__ function's input. See this excerpt from the query result: { \"inputs\": [ { \"type\": \"CallArray[1]\", \"value\": [ { \"to\": \"0x4c5327da1f289477951750208c9f97ca0f53afcd256d4363060268750b07f92\", \"data_len\": \"0x3\", \"selector\": \"0x219209e083275171774dab1df80982e9df2096516f06319c5c6d71ae0a8480c\", \"data_offset\": \"0x0\" } ], \"name\": \"call_array\" }, { \"type\": \"felt[3]\", \"value\": [ \"0x30295374333e5b9fc34de3ef3822867eaa99af4c856ecf624d34574f8d7d8ea\", \"0xffffffffffffffffffffffffffffffff\", \"0xffffffffffffffffffffffffffffffff\" ], \"name\": \"calldata\" }, { \"type\": \"felt\", \"value\": \"0x0\", \"name\": \"nonce\" } ], \"function\": \"__execute__\" }","title":"Proxy contracts"},{"location":"queries/#aggregation","text":"By now you know how to query for all your inputs and events, but how do you interpret them: sum them up, compare or calculate? Let's say you want to derive a number from some of your events, for example, to calculate Total Value Locked, which is a sum of arguments amount0 of all Mint events. One approach is to query for all of the values of amount0 ; here we limit results to 10 for brevity. { starknet_goerli_argument(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }, limit: 10) { type value name decimal } } See the values as Uint256 struct and also conveniently converted into decimals so you can sum them up. { \"type\": \"Uint256\", \"value\": { \"low\": \"0x52b7d2dcc80cd2e4000000\", \"high\": \"0x0\" }, \"name\": \"amount0\", \"decimal\": \"100000000000000000000000000\" } You can consume this query's results by your own software and sum up the values of amount0 . This is the approach of some other indexers. But since your data is already in a relational database's table, you can run an aggregation query over the values, which sums them up and returns the final result in the same query, all with no extra coding effort. That's why the values were converted into decimals when they were persisted: GraphQL query argument_aggregate calls a SQL query with an aggregation function sum over a numeric column. Database type numeric 78 used for the decimal column is large enough to support Uint256 and felt and arithmetic operations over them. This query aggregates decimal values of amount0 arguments of all Mint events. { starknet_goerli_argument_aggregate(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }) { aggregate { sum { decimal } avg { decimal } min { decimal } max { decimal } } } } Returns the total sum (TVL) as well as results of other aggregation functions: min, max, avg. { \"data\": { \"argument_aggregate\": { \"aggregate\": { \"sum\": { \"decimal\": \"7312519852578770281612328156\" }, \"avg\": { \"decimal\": \"148767543894266393001838\" }, \"min\": { \"decimal\": \"25047631971864\" }, \"max\": { \"decimal\": \"5000000000000000000000000000\" } } } } }","title":"Aggregation"},{"location":"sql/","text":"Query blockchain data with SQL Blockchain data we collect and index is stored in a relational database so it is natural to provide access to it with its native query language SQL . Compare to GraphQL We find GraphQL well suited for data exploration, API access and some analysis. GraphQL works well for queries fetching blockchain data with any level of detail, and it lets you join and filter entities. You can use it to sum up values for analysis with aggregation queries. For the majority of use cases in can replace SQL. Let's go through some queries and compare their implementation in both GraphQL and SQL. We'll see they're equivalent until more complex cases arise which GraphQL cannot handle and we'll have to switch to SQL. Selects The following two queries fetch payload arguments named amount0 of event Mint of contract 0x4b05... . { starknet_goerli_argument( where: { event: { transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}, name: {_eq: \"Mint\"} }, name: {_eq: \"amount0\"} } order_by: {event: {transaction: {block: {block_number: desc}}}} limit: 10 ) { event { transaction { block { block_number } } } name type value decimal } } The SQL query is as concise as GraphQL except perhaps for the verbose join s. select a.name, a.type, a.value, a.decimal, b.block_number from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id left join starknet_goerli.transaction t on e.transaction_hash = t.transaction_hash left join starknet_goerli.block b on t.block_number = b.block_number where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0' order by b.block_number desc limit 10; Open the SQL editor in the web console to try the query. You may find GraphQL more useful here as it returns easy to consume json output instead of rows returned by SQL. Aggregations Let's try aggregation queries to sum up values of our argument amount0 . select sum(a.decimal) as sum from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0'; { starknet_goerli_argument_aggregate(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }) { aggregate { sum { decimal } } } } Both queries arrive at the same number 7468354995607923658930301617 which may tell you something. So far both GraphQL and SQL get the job done. Complex aggregations Now for a more meaningful analysis let's try to calculate daily mint volume of a given smart contract. We would need to sum up all amount0 values of Mint events emitted per day. We determine date by timestamp fields of block s that contains transactions with our events, and would need to round them up to date s. Alas, this is not possible with the GraphQL aggregation queries we have available. But SQL does it well with its functions and the aggregation keyword group by . select (to_timestamp((b.\"timestamp\"))) :: date as dt, sum(a.decimal) as sum from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id left join starknet_goerli.transaction t on e.transaction_hash = t.transaction_hash left join starknet_goerli.block b on t.block_number = b.block_number where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0' group by dt order by dt desc limit 10; Returns a table you can interpret and perhaps make a chart out of. Views You can use the full power and flexibility of SQL in the web console and observe the results in the output table. But can you consume these results as easily as you do the ones from GraphQL? Which returns json and can be called via http. Yes you can, with the help of views which can turn your SQL select statements into GraphQL queries. Enter SQL select statement of your query into the web console editor. But instead of Run Query switch to create view , give it a name then Create view . We'll persist your query as a database view and make it available as a GraphQL query node. Note its name will be prefixed with user_ to distinguish it from the existing entities. You can find this new query user_daily_mint in the Explorer and run it just like any other GraphQL query. The query can also be called via API and its results can be easily consumed as json. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_daily_mint {dt sum}}\"}' Examples Let's look at a couple of examples that show how SQL can be used to analyse blockchain data, then can be turned into persistent GraphQL queries to be consumed via our API. Daily transaction count This SQL select counts total transactions per day. Note the familiar rounding of block.timestamp to date which we use to group by . select to_timestamp(b.timestamp) :: date as dt, count(t.transaction_hash) from starknet_goerli.transaction as t left join starknet_goerli.block b on t.block_number = b.block_number group by dt order by dt desc With this select we create daily_transactions view in the web console's SQL editor... ... to find user_daily_transactions node in GraphQL Explorer. And call the query with http API. Results of such statistical queries can be used to construct charts. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_daily_transactions {dt count}}\"}' Top functions This SQL select counts the number of smart contract function invocations and sorts them by the this count to show the ones called the most. select t.function, count(t.function) ct from starknet_goerli.transaction t group by t.function order by ct desc; GraphQL query created from this select user_top_functions ... { user_top_functions(limit: 5) { function ct } } ... returns 5 most popular functions. { \"data\": { \"user_top_functions\": [ { \"function\": \"__execute__\", \"ct\": \"5558963\" }, { \"function\": \"execute\", \"ct\": \"1414980\" }, { \"function\": \"constructor\", \"ct\": \"978904\" }, { \"function\": \"anonymous\", \"ct\": \"763224\" }, { \"function\": \"initialize\", \"ct\": \"322249\" } ] } } Try it via http API. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_top_functions {function ct}}\"}' The above examples show that you can use SQL queries which can be rather complex, to aggregate over any data you may be interested in. In most cases no separate indexer process is needed to interpret your data. If however you want to do something that SQL, even with custom views cannot, you can query for specific data with GraphQL then consume the results by your own software which will interpret it.","title":"SQL"},{"location":"sql/#query-blockchain-data-with-sql","text":"Blockchain data we collect and index is stored in a relational database so it is natural to provide access to it with its native query language SQL .","title":"Query blockchain data with SQL"},{"location":"sql/#compare-to-graphql","text":"We find GraphQL well suited for data exploration, API access and some analysis. GraphQL works well for queries fetching blockchain data with any level of detail, and it lets you join and filter entities. You can use it to sum up values for analysis with aggregation queries. For the majority of use cases in can replace SQL. Let's go through some queries and compare their implementation in both GraphQL and SQL. We'll see they're equivalent until more complex cases arise which GraphQL cannot handle and we'll have to switch to SQL.","title":"Compare to GraphQL"},{"location":"sql/#selects","text":"The following two queries fetch payload arguments named amount0 of event Mint of contract 0x4b05... . { starknet_goerli_argument( where: { event: { transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}, name: {_eq: \"Mint\"} }, name: {_eq: \"amount0\"} } order_by: {event: {transaction: {block: {block_number: desc}}}} limit: 10 ) { event { transaction { block { block_number } } } name type value decimal } } The SQL query is as concise as GraphQL except perhaps for the verbose join s. select a.name, a.type, a.value, a.decimal, b.block_number from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id left join starknet_goerli.transaction t on e.transaction_hash = t.transaction_hash left join starknet_goerli.block b on t.block_number = b.block_number where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0' order by b.block_number desc limit 10; Open the SQL editor in the web console to try the query. You may find GraphQL more useful here as it returns easy to consume json output instead of rows returned by SQL.","title":"Selects"},{"location":"sql/#aggregations","text":"Let's try aggregation queries to sum up values of our argument amount0 . select sum(a.decimal) as sum from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0'; { starknet_goerli_argument_aggregate(where: { name: {_eq: \"amount0\"}, event: {name: {_eq: \"Mint\"}, transmitter_contract: {_eq: \"0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733\"}} }) { aggregate { sum { decimal } } } } Both queries arrive at the same number 7468354995607923658930301617 which may tell you something. So far both GraphQL and SQL get the job done.","title":"Aggregations"},{"location":"sql/#complex-aggregations","text":"Now for a more meaningful analysis let's try to calculate daily mint volume of a given smart contract. We would need to sum up all amount0 values of Mint events emitted per day. We determine date by timestamp fields of block s that contains transactions with our events, and would need to round them up to date s. Alas, this is not possible with the GraphQL aggregation queries we have available. But SQL does it well with its functions and the aggregation keyword group by . select (to_timestamp((b.\"timestamp\"))) :: date as dt, sum(a.decimal) as sum from starknet_goerli.argument a left join starknet_goerli.event e on a.event_id = e.id left join starknet_goerli.transaction t on e.transaction_hash = t.transaction_hash left join starknet_goerli.block b on t.block_number = b.block_number where e.transmitter_contract = '0x4b05cce270364e2e4bf65bde3e9429b50c97ea3443b133442f838045f41e733' and e.name = 'Mint' and a.name = 'amount0' group by dt order by dt desc limit 10; Returns a table you can interpret and perhaps make a chart out of.","title":"Complex aggregations"},{"location":"sql/#views","text":"You can use the full power and flexibility of SQL in the web console and observe the results in the output table. But can you consume these results as easily as you do the ones from GraphQL? Which returns json and can be called via http. Yes you can, with the help of views which can turn your SQL select statements into GraphQL queries. Enter SQL select statement of your query into the web console editor. But instead of Run Query switch to create view , give it a name then Create view . We'll persist your query as a database view and make it available as a GraphQL query node. Note its name will be prefixed with user_ to distinguish it from the existing entities. You can find this new query user_daily_mint in the Explorer and run it just like any other GraphQL query. The query can also be called via API and its results can be easily consumed as json. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_daily_mint {dt sum}}\"}'","title":"Views"},{"location":"sql/#examples","text":"Let's look at a couple of examples that show how SQL can be used to analyse blockchain data, then can be turned into persistent GraphQL queries to be consumed via our API.","title":"Examples"},{"location":"sql/#daily-transaction-count","text":"This SQL select counts total transactions per day. Note the familiar rounding of block.timestamp to date which we use to group by . select to_timestamp(b.timestamp) :: date as dt, count(t.transaction_hash) from starknet_goerli.transaction as t left join starknet_goerli.block b on t.block_number = b.block_number group by dt order by dt desc With this select we create daily_transactions view in the web console's SQL editor... ... to find user_daily_transactions node in GraphQL Explorer. And call the query with http API. Results of such statistical queries can be used to construct charts. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_daily_transactions {dt count}}\"}'","title":"Daily transaction count"},{"location":"sql/#top-functions","text":"This SQL select counts the number of smart contract function invocations and sorts them by the this count to show the ones called the most. select t.function, count(t.function) ct from starknet_goerli.transaction t group by t.function order by ct desc; GraphQL query created from this select user_top_functions ... { user_top_functions(limit: 5) { function ct } } ... returns 5 most popular functions. { \"data\": { \"user_top_functions\": [ { \"function\": \"__execute__\", \"ct\": \"5558963\" }, { \"function\": \"execute\", \"ct\": \"1414980\" }, { \"function\": \"constructor\", \"ct\": \"978904\" }, { \"function\": \"anonymous\", \"ct\": \"763224\" }, { \"function\": \"initialize\", \"ct\": \"322249\" } ] } } Try it via http API. curl https://hasura.dev.summary.dev/v1/graphql --data-raw '{\"query\":\"{user_top_functions {function ct}}\"}' The above examples show that you can use SQL queries which can be rather complex, to aggregate over any data you may be interested in. In most cases no separate indexer process is needed to interpret your data. If however you want to do something that SQL, even with custom views cannot, you can query for specific data with GraphQL then consume the results by your own software which will interpret it.","title":"Top functions"},{"location":"subscriptions/","text":"Subscriptions A GraphQL subscription is essentially a query where the client receives an update whenever the value of any field changes upstream. Subscriptions are supported for all kinds of queries. All the concepts of queries hold true for subscriptions as well. The subscription will return the latest result of the query being made and not necessarily all the individual events leading up to the result. By default, updates are delivered to clients every 1 sec. GraphQL Console You can turn any query into a subscription by simply replacing query with subscription as the operation type. Let's try this query in the web console . It fetches names of the three latest events emitted by smart contracts in StarkNet goerli chain. To get the latest we order_by auto incremented event id descending. query latest_events { starknet_goerli_event(limit: 3, order_by: {id: desc}) { id name } } You should receive results similar to these. If you keep executing the query, you'll be getting more recent events, still limited to the 3 latest ones. { \"data\": { \"starknet_goerli_event\": [ { \"id\": 34127040, \"name\": \"Transfer\" }, { \"id\": 34127039, \"name\": \"SubmittedEntry\" }, { \"id\": 34127038, \"name\": \"SubmittedEntry\" } ] } } Now change the operation type from query to subscription . subscription latest_events { starknet_goerli_event(limit: 3, order_by: {id: desc}) { id name } } Click the execution button and see the results start updating automatically in the results pane. Note the button icon changed from play to stop . Node.js We put together a simple example client that subscribes to the blockchain indexer. It is just a few lines of javascript code in subscriber Github repo . Use it as a starting point for your own client that reacts to blockchain events. The example client will wait for events which represent changes in the results of a GraphQL query, will print them out and exit after three events have been received. Its default subscription query fetches the three latest blocks. subscription { starknet_goerli_block(limit: 3, order_by: {block_number: desc}) { block_number, block_hash }} You can pass your own subscription query as an argument. The following query waits for the latest events emitted. Note both this and the default query order results ordered desc to get the latest. If you query without ordering you'll get the first rows which don't change and don't trigger events. npm start 'subscription {starknet_goerli_event(limit: 3, order_by: {id: desc}) {id, name}}' Communication protocol Our backend Hasura GraphQL engine uses the GraphQL over WebSocket Protocol by the apollographql/subscriptions-transport-ws library and the GraphQL over WebSocket Protocol by the graphql-ws library for sending and receiving events. The GraphQL engine uses the Sec-WebSocket-Protocol header to determine the communication protocol that'll be used. By default, the GraphQL engine will use the apollographql/subscriptions-transport-ws protocol.","title":"Subscriptions"},{"location":"subscriptions/#subscriptions","text":"A GraphQL subscription is essentially a query where the client receives an update whenever the value of any field changes upstream. Subscriptions are supported for all kinds of queries. All the concepts of queries hold true for subscriptions as well. The subscription will return the latest result of the query being made and not necessarily all the individual events leading up to the result. By default, updates are delivered to clients every 1 sec.","title":"Subscriptions"},{"location":"subscriptions/#graphql-console","text":"You can turn any query into a subscription by simply replacing query with subscription as the operation type. Let's try this query in the web console . It fetches names of the three latest events emitted by smart contracts in StarkNet goerli chain. To get the latest we order_by auto incremented event id descending. query latest_events { starknet_goerli_event(limit: 3, order_by: {id: desc}) { id name } } You should receive results similar to these. If you keep executing the query, you'll be getting more recent events, still limited to the 3 latest ones. { \"data\": { \"starknet_goerli_event\": [ { \"id\": 34127040, \"name\": \"Transfer\" }, { \"id\": 34127039, \"name\": \"SubmittedEntry\" }, { \"id\": 34127038, \"name\": \"SubmittedEntry\" } ] } } Now change the operation type from query to subscription . subscription latest_events { starknet_goerli_event(limit: 3, order_by: {id: desc}) { id name } } Click the execution button and see the results start updating automatically in the results pane. Note the button icon changed from play to stop .","title":"GraphQL Console"},{"location":"subscriptions/#nodejs","text":"We put together a simple example client that subscribes to the blockchain indexer. It is just a few lines of javascript code in subscriber Github repo . Use it as a starting point for your own client that reacts to blockchain events. The example client will wait for events which represent changes in the results of a GraphQL query, will print them out and exit after three events have been received. Its default subscription query fetches the three latest blocks. subscription { starknet_goerli_block(limit: 3, order_by: {block_number: desc}) { block_number, block_hash }} You can pass your own subscription query as an argument. The following query waits for the latest events emitted. Note both this and the default query order results ordered desc to get the latest. If you query without ordering you'll get the first rows which don't change and don't trigger events. npm start 'subscription {starknet_goerli_event(limit: 3, order_by: {id: desc}) {id, name}}'","title":"Node.js"},{"location":"subscriptions/#communication-protocol","text":"Our backend Hasura GraphQL engine uses the GraphQL over WebSocket Protocol by the apollographql/subscriptions-transport-ws library and the GraphQL over WebSocket Protocol by the graphql-ws library for sending and receiving events. The GraphQL engine uses the Sec-WebSocket-Protocol header to determine the communication protocol that'll be used. By default, the GraphQL engine will use the apollographql/subscriptions-transport-ws protocol.","title":"Communication protocol"}]}